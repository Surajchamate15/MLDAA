// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.2 <0.9.0;

contract BankContract {

    struct ClientAccount {
        int client_id;
        address client_address;
        uint client_balance_in_ether;
    }

    ClientAccount[] clients;

    int clientCounter;
    address payable manager;
    mapping(address => uint) public interestDate;

    modifier onlyManager() {
        require(msg.sender == manager, "Only manager can call this!");
        _;
    }

    modifier onlyClients() {
        bool isClient = false;
        for (uint i = 0; i < clients.length; i++) {
            if (clients[i].client_address == msg.sender) {
                isClient = true;
                break;
            }
        }
        require(isClient, "Only clients can call this!");
        _;
    }

    constructor() {
        clientCounter = 0;
    }

    receive() external payable {}

    function setManager(address managerAddress) public {
        manager = payable(managerAddress);
    }

    function joinAsClient() public payable {
        interestDate[msg.sender] = block.timestamp;
        clients.push(ClientAccount(clientCounter++, msg.sender, address(msg.sender).balance));
    }

    function deposit() public payable onlyClients {
        // No need to use payable here, just transfer the value
        payable(address(this)).transfer(msg.value);
    }

    function withdraw(uint amount) public onlyClients {
        require(amount <= address(this).balance, "Insufficient contract balance");
        payable(msg.sender).transfer(amount);
    }

    function sendInterest() public onlyManager {
        for (uint i = 0; i < clients.length; i++) {
            address initialAddress = clients[i].client_address;
            uint lastInterestDate = interestDate[initialAddress];
            require(block.timestamp >= lastInterestDate + 10 seconds, "Less than 10 seconds have passed");
            payable(initialAddress).transfer(1 ether);
            interestDate[initialAddress] = block.timestamp;
        }
    }

    function getContractBalance() public view returns (uint) {
        return address(this).balance;
    }
}